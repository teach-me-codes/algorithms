[
    {
        "domain": "Data Structure and Algorithms",
        "titles": "Introduction",
        "detail": "Data Structures and Algorithms form the foundation of computer science. They provide methods for organizing and manipulating data efficiently and solving complex computational problems.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Basic Data Structures",
        "titles": "Lists",
        "detail": "Lists in Python are dynamic arrays that can store elements of different types. They support various operations such as indexing, slicing, and appending.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Basic Data Structures",
        "titles": "Tuples",
        "detail": "Tuples are immutable sequences in Python that can store elements of different types. They are often used to group related data.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Basic Data Structures",
        "titles": "Sets",
        "detail": "Sets are unordered collections of unique elements. They support operations like union, intersection, and difference, and are useful for membership testing and eliminating duplicates.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Basic Data Structures",
        "titles": "Dictionaries",
        "detail": "Dictionaries are key-value pairs in Python, providing an efficient way to store and retrieve data based on unique keys.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Basic Data Structures",
        "titles": "Strings",
        "detail": "Strings are immutable sequences of characters. They support various operations such as concatenation, slicing, and pattern matching using regular expressions.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Linked Lists",
        "detail": "Linked Lists are sequences of nodes where each node contains a data element and a reference to the next node. Types include singly linked lists, doubly linked lists, and circular linked lists.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Stacks",
        "detail": "Stacks are LIFO (Last In, First Out) data structures that allow adding and removing elements from the top. They are used in function call management and expression evaluation.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Queues",
        "detail": "Queues are FIFO (First In, First Out) data structures that allow adding elements at the rear and removing elements from the front. Types include simple queues, circular queues, and priority queues.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Priority Queues",
        "detail": "Priority Queues are data structures where each element has a priority, and elements are dequeued in order of their priority. They are typically implemented using heaps.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Heaps",
        "detail": "Heaps are complete binary trees used to implement priority queues. Types include min-heaps and max-heaps, which support efficient retrieval of the minimum or maximum element, respectively.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Hash Tables",
        "detail": "Hash Tables are data structures that map keys to values using a hash function. They provide efficient data retrieval and are the underlying structure for Python dictionaries.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Trees",
        "detail": "Trees are hierarchical data structures with nodes connected by edges. Types include binary trees, binary search trees, AVL trees, red-black trees, and B-trees.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Data Structures",
        "titles": "Graphs",
        "detail": "Graphs are collections of nodes connected by edges. Types include undirected graphs, directed graphs, weighted graphs, and unweighted graphs.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Basics",
        "titles": "Algorithm Analysis",
        "detail": "Algorithm Analysis involves determining the efficiency of algorithms in terms of time and space complexity, using Big O notation, Big Theta, and Big Omega.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Basics",
        "titles": "Recursion",
        "detail": "Recursion is a technique where a function calls itself to solve smaller instances of the same problem. It is used in problems like factorial computation and tree traversal.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Basics",
        "titles": "Sorting Algorithms",
        "detail": "Sorting Algorithms arrange elements in a specific order. Common sorting algorithms include bubble sort, selection sort, insertion sort, merge sort, quicksort, and heap sort.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Basics",
        "titles": "Searching Algorithms",
        "detail": "Searching Algorithms are used to find elements in data structures. Common searching algorithms include linear search, binary search, and depth-first and breadth-first searches for graphs.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Techniques",
        "titles": "Divide and Conquer",
        "detail": "Divide and Conquer is an algorithm design paradigm that breaks a problem into smaller subproblems, solves each subproblem, and combines the results. Examples include merge sort and quicksort.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Techniques",
        "titles": "Dynamic Programming",
        "detail": "Dynamic Programming is a technique used to solve problems by breaking them down into simpler subproblems and storing the results of subproblems to avoid redundant computations. Examples include Fibonacci sequence and knapsack problem.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Techniques",
        "titles": "Greedy Algorithms",
        "detail": "Greedy Algorithms make a series of choices, each of which looks the best at the moment, to find a global optimum. Examples include the coin change problem and Kruskal's algorithm.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Techniques",
        "titles": "Backtracking",
        "detail": "Backtracking is a technique for solving problems incrementally by trying partial solutions and then abandoning them if they are not suitable. Examples include the N-Queens problem and Sudoku solver.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Algorithm Techniques",
        "titles": "Branch and Bound",
        "detail": "Branch and Bound is a technique for solving optimization problems by systematically enumerating candidate solutions. It is used in problems like traveling salesman and knapsack problem.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Depth-First Search",
        "detail": "DFS is a graph traversal algorithm that explores as far along a branch as possible before backtracking. It is used for pathfinding, cycle detection, and topological sorting.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Breadth-First Search",
        "detail": "BFS is a graph traversal algorithm that explores all neighbors of a node before moving on to the next level. It is used for shortest path finding in unweighted graphs and level order traversal.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Dijkstra's Algorithm",
        "detail": "Dijkstra's Algorithm finds the shortest paths from a source node to all other nodes in a weighted graph. It is used in network routing protocols and geographical mapping applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Bellman-Ford Algorithm",
        "detail": "Bellman-Ford Algorithm computes the shortest paths from a source node to all other nodes in a weighted graph, handling negative weights. It is used in routing and scheduling applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "A* Algorithm",
        "detail": "A* Algorithm is a pathfinding and graph traversal algorithm that finds the shortest path between nodes using heuristics. It is used in AI applications, such as game development and robotics.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Kruskal's Algorithm",
        "detail": "Kruskal's Algorithm finds the minimum spanning tree for a connected weighted graph, using a greedy approach. It is used in network design and clustering applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Prim's Algorithm",
        "detail": "Prim's Algorithm finds the minimum spanning tree for a connected weighted graph, using a greedy approach. It is used in network design and optimization problems.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Floyd-Warshall Algorithm",
        "detail": "Floyd-Warshall Algorithm finds shortest paths between all pairs of nodes in a weighted graph. It is used in routing and network optimization applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Graph Algorithms",
        "titles": "Topological Sort",
        "detail": "Topological Sort orders the nodes in a directed acyclic graph (DAG) such that for every directed edge u -> v, node u comes before node v. It is used in scheduling and dependency resolution.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Tries",
        "detail": "Tries, or prefix trees, are tree-like data structures that store strings and allow for efficient prefix-based search. They are used in autocomplete and spell-checking applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Segment Trees",
        "detail": "Segment Trees are data structures that allow for efficient range queries and updates on arrays. They are used in applications like interval queries and dynamic programming.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Fenwick Trees",
        "detail": "Fenwick Trees, or binary indexed trees, are data structures that allow for efficient prefix sum queries and updates. They are used in frequency analysis and cumulative sum problems.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Suffix Arrays and Trees",
        "detail": "Suffix Arrays and Suffix Trees are data structures used for efficient string searching and matching. They are used in text indexing and DNA sequencing applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Bloom Filters",
        "detail": "Bloom Filters are probabilistic data structures used to test whether an element is a member of a set. They are used in database systems and network filtering applications.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Advanced Topics",
        "titles": "Union-Find",
        "detail": "Union-Find, or Disjoint Set Union (DSU), is a data structure that tracks a set of elements partitioned into disjoint subsets. It is used in network connectivity and Kruskal's algorithm.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Optimization",
        "titles": "Memoization",
        "detail": "Memoization is an optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again. It is used in dynamic programming and recursive algorithms.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Optimization",
        "titles": "Time Complexity",
        "detail": "Time Complexity measures the time taken by an algorithm to run as a function of the length of the input. It is analyzed using Big O, Big Theta, and Big Omega notations.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Optimization",
        "titles": "Space Complexity",
        "detail": "Space Complexity measures the amount of memory space an algorithm uses as a function of the length of the input. It is analyzed using Big O, Big Theta, and Big Omega notations.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Optimization",
        "titles": "Amortized Analysis",
        "detail": "Amortized Analysis provides an average performance guarantee over a sequence of operations, ensuring that the average cost per operation is small, even if some operations are expensive.",
        "subject": "Data Structure and Algorithms"
    },
    {
        "domain": "Parallel and Distributed Algorithms",
        "titles": "MapReduce",
        "detail": "MapReduce is a programming model used for processing large data sets with a distributed algorithm on a cluster. It consists of a Map step that processes key-value pairs and a Reduce step that aggregates the results.",
        "subject": "Data Structure and Algorithms"
    }
]
